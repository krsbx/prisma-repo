import {
  IMPORT_LIBRARY,
  INSTANCE_NAME,
  INTERFACE_NAME,
  PRISMA_TYPES,
  BASE_REPOSITORY_TYPE,
  TYPES_NAMES,
  BASE_REPOSITORY_MODEL_NAME,
  BASE_REPOSITORY_BASE_TYPE,
  REPOSITORY_TYPE,
} from '../utils/constants';

const baseRepository = `/* eslint-disable @typescript-eslint/ban-ts-comment */
// Keep in mind that this file is automatically generated.
// You can change the content of this file, but it will be overwritten.

${IMPORT_LIBRARY.LODASH}
${IMPORT_LIBRARY.PRISMA}
import { ${INSTANCE_NAME.MODELS}, ${TYPES_NAMES.MODEL_NAME}, ${TYPES_NAMES.MODEL_STRUCTURE}, ${TYPES_NAMES.MODEL_SCALAR_FIELDS}, ${INTERFACE_NAME.ANY_RECORD}, ${INTERFACE_NAME.FIND}, ${INTERFACE_NAME.BASE_OPTION}, ${TYPES_NAMES.MODEL_TYPES} } from './models';

/**
 * @param model - The model name
 */

export class BaseRepository<${BASE_REPOSITORY_BASE_TYPE.CONSTRUCTOR}> {
  constructor(protected model: ${TYPES_NAMES.MODEL_NAME}) {
    ${BASE_REPOSITORY_MODEL_NAME} = model;
  }

  async findAll(
    conditions: ${REPOSITORY_TYPE.WHERE},
    filterQueryParams: ${INTERFACE_NAME.ANY_RECORD} = {},
    options: ${INTERFACE_NAME.ANY_RECORD} = {},
    include: ${REPOSITORY_TYPE.INCLUDE} = {} as ${REPOSITORY_TYPE.INCLUDE}
  ) {
    const limit = +(options.limit === 'all' ? 0 : _.get(options, 'limit', 10));
    const offset = options.page && options.page > 0 ? limit * (options.page - 1) : 0;
    const otherOptions = _.omit(options, ['limit', 'offset', 'page']);

    const where = { ...conditions, ...filterQueryParams, ...otherOptions };

    return {
      // @ts-ignore
      rows: (await ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].findMany({
        where,
        ...(!_.isEmpty(include) && { include }),
        skip: offset,
        ...(limit > 0 && { take: limit }),
      })) as ${REPOSITORY_TYPE.MODEL}[],
      // eslint-disable-next-line no-underscore-dangle
      count: /* @ts-ignore */ (
        await ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].aggregate({
          where,
          _count: true,
        })
      )._count as number,
    };
  }

  async findOne(
    conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
    option: ${BASE_REPOSITORY_TYPE.FIND_OPTION} = {}
  ) {
    const dbCond = _.isObject(conditions) ? conditions : { id: _.toNumber(conditions) };

    // @ts-ignore
    return ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].findFirst({
      where: dbCond,
      ...option,
    }) as Promise<${REPOSITORY_TYPE.MODEL}>;
  }

  async create(
    data: ${REPOSITORY_TYPE.CREATE},
    option: ${BASE_REPOSITORY_TYPE.CREATE_UPDATE_OPTION} = {}
  ) {
    // @ts-ignore
    return ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].create({
      data,
      ...option,
    }) as Promise<${REPOSITORY_TYPE.MODEL}>;
  }

  async update(
    conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
    data: ${BASE_REPOSITORY_TYPE.UPDATE_CREATE_PAYLOAD},
    option: ${BASE_REPOSITORY_TYPE.CREATE_UPDATE_OPTION} = {}
  ) {
    const dbCond = _.isObject(conditions) ? conditions : { id: _.toNumber(conditions) };

    // @ts-ignore
    return ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].update({
      data,
      where: dbCond,
      ...option,
    }) as Promise<${REPOSITORY_TYPE.MODEL}>;
  }

  async delete(conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS}) {
    const dbCond = _.isObject(conditions) ? conditions : { id: _.toNumber(conditions) };

    // @ts-ignore
    return ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].deleteMany({
      where: dbCond,
    }) as Promise<${PRISMA_TYPES.BATCH_PAYLOAD}>;
  }

  async updateOrCreate(
    conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
    data: ${REPOSITORY_TYPE.CREATE},
    option: ${BASE_REPOSITORY_TYPE.FIND_OPTION} = {}
  ) {
    const obj = await this.findOne(conditions, option);

    if (obj) return this.update(conditions, data, option);

    return this.create(data);
  }

  async bulkCreate(data: ${BASE_REPOSITORY_TYPE.ENUMERABLE_CREATE}, skipDuplicates = true) {
    // @ts-ignore
    return ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].createMany({
      data,
      skipDuplicates,
    }) as Promise<${PRISMA_TYPES.BATCH_PAYLOAD}>;
  }

  async bulkUpdate(where: ${REPOSITORY_TYPE.WHERE}, data: ${BASE_REPOSITORY_TYPE.ENUMERABLE_UPDATE}) {
    // @ts-ignore
    return ${INSTANCE_NAME.MODELS}[${BASE_REPOSITORY_MODEL_NAME}].updateMany({
      data,
      where,
    }) as Promise<${PRISMA_TYPES.BATCH_PAYLOAD}>;
  }
}

const factory = <${BASE_REPOSITORY_TYPE.EXTEND_MODEL_NAME}>(model: T) => 
  new BaseRepository<
  ${BASE_REPOSITORY_BASE_TYPE.WHERE},
  ${BASE_REPOSITORY_BASE_TYPE.SELECT},
  ${BASE_REPOSITORY_BASE_TYPE.INCLUDE},
  ${BASE_REPOSITORY_BASE_TYPE.CREATE},
  ${BASE_REPOSITORY_BASE_TYPE.UPDATE},
  ${BASE_REPOSITORY_BASE_TYPE.CURSOR},
  ${BASE_REPOSITORY_BASE_TYPE.ORDER},
  ${BASE_REPOSITORY_BASE_TYPE.SCALAR},
  ${BASE_REPOSITORY_TYPE.MODEL_STRUCTURE}
  >(model);

export default factory;
`;

export default baseRepository;
