import {
  IMPORT_LIBRARY,
  INSTANCE_NAME,
  INTERFACE_NAME,
  PRISMA_TYPES,
  BASE_REPOSITORY_TYPE,
  TYPES_NAMES,
  BASE_REPOSITORY_BASE_TYPE,
  REPOSITORY_TYPE,
  CLASS_NAME,
  PACKAGE_NAME,
} from '../utils/constants';

const baseRepository = `/* eslint-disable @typescript-eslint/ban-ts-comment */
// Keep in mind that this file is automatically generated.
// You can change the content of this file, but it will be overwritten.

${IMPORT_LIBRARY.LODASH}
${IMPORT_LIBRARY.PRISMA}
import { ${INSTANCE_NAME.MODELS}, ${TYPES_NAMES.MODEL_NAME}, ${TYPES_NAMES.MODEL_STRUCTURE}, ${TYPES_NAMES.MODEL_SCALAR_FIELDS}, ${INTERFACE_NAME.ANY_RECORD}, ${INTERFACE_NAME.BASE_OPTION}, ${INTERFACE_NAME.FIND}, ${INTERFACE_NAME.COUNT_ARGS}, ${INTERFACE_NAME.AGGREGATE}, ${TYPES_NAMES.MODEL_TYPES} } from './${PACKAGE_NAME}';

/**
 * @param modelName - The model name
 */

const ${CLASS_NAME.BASE_REPOSITORY} = <
  ${BASE_REPOSITORY_TYPE.EXTEND_MODEL_NAME},
  ${REPOSITORY_TYPE.WHERE} extends ${BASE_REPOSITORY_BASE_TYPE.WHERE},
  ${REPOSITORY_TYPE.SELECT} extends ${BASE_REPOSITORY_BASE_TYPE.SELECT},
  ${REPOSITORY_TYPE.INCLUDE} extends ${BASE_REPOSITORY_BASE_TYPE.INCLUDE},
  ${REPOSITORY_TYPE.CREATE} extends ${BASE_REPOSITORY_BASE_TYPE.CREATE},
  ${REPOSITORY_TYPE.UPDATE} extends ${BASE_REPOSITORY_BASE_TYPE.UPDATE},
  ${REPOSITORY_TYPE.CURSOR} extends ${BASE_REPOSITORY_BASE_TYPE.CURSOR},
  ${REPOSITORY_TYPE.ORDER} extends ${BASE_REPOSITORY_BASE_TYPE.ORDER},
  ${REPOSITORY_TYPE.DELEGATE} extends ${BASE_REPOSITORY_BASE_TYPE.DELEGATE},
  ${REPOSITORY_TYPE.SCALAR} extends ${BASE_REPOSITORY_BASE_TYPE.SCALAR},
  ${REPOSITORY_TYPE.MODEL} extends ${BASE_REPOSITORY_TYPE.MODEL_STRUCTURE}
>(modelName: T) => {
  abstract class ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY} {
    protected static modelName: T = modelName;

    // eslint-disable-next-line class-methods-use-this
    private static extractCondition(conditions: ${REPOSITORY_TYPE.CURSOR} | ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS}) {
      const dbCond = _.isObject(conditions) ? conditions : { id: _.toNumber(conditions) };

      return dbCond;
    }

    public static async findAll(
      conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
      filterQueryParams: ${INTERFACE_NAME.ANY_RECORD} = {},
      query: ${INTERFACE_NAME.ANY_RECORD} = {},
      option: ${BASE_REPOSITORY_TYPE.FIND_OPTION} = {}
    ) {
      const limit = +(query.limit === 'all' ? 0 : _.get(query, 'limit', 10));
      const offset = query.page && query.page > 0 ? limit * (query.page - 1) : 0;
      const otherOptions = _.omit(query, ['limit', 'offset', 'page']);

      const where = { ...${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions), ...filterQueryParams, ...otherOptions };

      return {
        // @ts-ignore
        rows: (await ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.findMany({
          where,
          ...option,
          skip: offset,
          ...(limit > 0 && { take: limit }),
        })) as ${REPOSITORY_TYPE.MODEL}[],
        /* @ts-ignore */
        count: await this.count(where),
      };
    }

    public static async findOne(
      conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
      option: ${BASE_REPOSITORY_TYPE.FIND_OPTION} = {}
    ) {
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.findFirst({ where, ...option }) as Promise<${REPOSITORY_TYPE.MODEL} | null>;
    }

    public static async findUnique(
      conditions: ${REPOSITORY_TYPE.CURSOR} | number | string,
      option: ${BASE_REPOSITORY_TYPE.CREATE_UPDATE_OPTION} = {}
    ) {
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.findUnique({ where, ...option }) as Promise<${REPOSITORY_TYPE.MODEL} | null>;
    }

    public static async create(data: ${REPOSITORY_TYPE.CREATE}, option: ${BASE_REPOSITORY_TYPE.CREATE_UPDATE_OPTION} = {}) {
      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.create({ data, ...option }) as Promise<${REPOSITORY_TYPE.MODEL}>;
    }

    public static async update(
      conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
      data: ${BASE_REPOSITORY_TYPE.UPDATE_CREATE_PAYLOAD},
      option: ${BASE_REPOSITORY_TYPE.CREATE_UPDATE_OPTION} = {}
    ) {
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.update({ data, where, ...option }) as Promise<${REPOSITORY_TYPE.MODEL}>;
    }

    public static async delete(conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS}) {
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.deleteMany({ where }) as Promise<${PRISMA_TYPES.BATCH_PAYLOAD}>;
    }

    public static async deleteOne(conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS}) {
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.delete({ where }) as Promise<${REPOSITORY_TYPE.MODEL}>;
    }

    public static async updateOrCreate(
      conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
      data: ${REPOSITORY_TYPE.CREATE},
      option: ${BASE_REPOSITORY_TYPE.FIND_OPTION} = {}
    ) {
      const obj = await ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.findOne(conditions, option);

      if (obj) return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.update(conditions, data, option);

      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.create(data);
    }

    public static async bulkCreate(data: ${BASE_REPOSITORY_TYPE.ENUMERABLE_CREATE}, skipDuplicates = true) {
      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.createMany({ data, skipDuplicates }) as Promise<${PRISMA_TYPES.BATCH_PAYLOAD}>;
    }

    public static async bulkUpdate(where: ${REPOSITORY_TYPE.WHERE}, data: ${BASE_REPOSITORY_TYPE.ENUMERABLE_UPDATE}) {
      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.updateMany({ data, where }) as Promise<${PRISMA_TYPES.BATCH_PAYLOAD}>;
    }

    public static async count(
      conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
      option: ${BASE_REPOSITORY_TYPE.COUNT_OPTION} = {}
    ) {
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      // @ts-ignore
      return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.count({ where, ...option }) as Promise<number>;
    }

    public static aggregate(
      conditions: ${BASE_REPOSITORY_TYPE.QUERY_CONDITIONS},
      aggregator: ${BASE_REPOSITORY_TYPE.AGGREGATE},
      option: ${BASE_REPOSITORY_TYPE.AGGREGATE_OPTION} = {}
    ) {
      // @ts-ignore
      const aggregate = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.model.aggregate as Delegate['aggregate'];
      const where = ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.extractCondition(conditions);

      if (_.isEmpty(aggregator)) {
        // @ts-ignore
        // eslint-disable-next-line no-param-reassign, no-underscore-dangle
        aggregator._count = true;
      }

      // @ts-ignore
      return aggregate({ where, ...aggregator, ...option }) as ReturnType<typeof aggregate>;
    }

    public static get model(): Delegate {
      // @ts-ignore
      return ${INSTANCE_NAME.MODELS}[${CLASS_NAME.ABSTRACT_BASE_REPOSITORY}.modelName];
    }
  }

  return ${CLASS_NAME.ABSTRACT_BASE_REPOSITORY};
}

export default ${CLASS_NAME.BASE_REPOSITORY};
`;

export default baseRepository;
